import sysimport numpy as npimport pyscffrom functools import reducefrom pyscf.lib import loggerfrom pyscf import lib# from lno.cc import TCCfrom pyscf import mcscf, ci, ccfrom lno.lno.base import LNOfrom functools import partialfrom pyscf.mp.mp2 import _mo_without_core_fdot = np.dotfdot = lambda *args: reduce(_fdot, args)einsum = lib.einsumr''' TODO's[x] customized CCSD to make PBC work[x] customized DFCCSD to make PBC work[x] (T)'''''' Beginning of modification of PySCF's (DF)CCSD class    The following functions are modified from pyscf.cc module    In PySCF, 1e integrals (s1e, h1e, vhf) are calculated whenever a CCSD object is    initialized. In LNOCCSD, this means that the same set of 1e integrals are evaluated    for every fragment. For PBC calculations, evaluating 1e integrals (especially h1e    and vhf) can be very slow in PySCF's current implementation.    The following modification forces the CCSD class to take precomputed 1e integrals    and thus can lead to significant amount of time saving in PBC LNOCCSD calculations.'''from pyscf.cc import ccsd, dfccsddef CCSD(mf, frozen=None, mo_coeff=None, mo_occ=None):    import numpy    from pyscf import lib    from pyscf.soscf import newton_ah    from pyscf import scf    log = logger.new_logger(mf)    if isinstance(mf, newton_ah._CIAH_SOSCF) or not isinstance(mf, scf.hf.RHF):        mf = scf.addons.convert_to_rhf(mf)    if getattr(mf, 'with_df', None):        ''' auto-choose if using DFCCSD (storing Lvv) or CCSD (storing vvvv) by memory        '''        naux = mf.with_df.get_naoaux()        if mo_occ is None: mo_occ = mf.mo_occ        maskocc = mo_occ > 1e-10        frozen, maskact = get_maskact(frozen, len(mo_occ))        nvir = np.count_nonzero(~maskocc&maskact)        nvir_pair = nvir*(nvir+1)//2        if naux > nvir_pair:            log.debug1('naux= %d > nvir_pair= %d -> using CCSD', naux, nvir_pair)            return MODIFIED_CCSD(mf, frozen, mo_coeff, mo_occ)        else:            log.debug1('naux= %d <= nvir_pair= %d -> using DFCCSD', naux, nvir_pair)            return MODIFIED_DFCCSD(mf, frozen, mo_coeff, mo_occ)    elif np.iscomplexobj(mo_coeff) or np.iscomplexobj(mf.mo_coeff):        log.error('Not implemented for now. Contact Hong-Zhou via hzyechem@gmail.com')        raise NotImplementedError    else:        return MODIFIED_CCSD(mf, frozen, mo_coeff, mo_occ)class MODIFIED_CCSD(ccsd.CCSD):    def ao2mo(self, mo_coeff=None):        # Pseudo code how eris are implemented:        # nocc = self.nocc        # nmo = self.nmo        # nvir = nmo - nocc        # eris = _ChemistsERIs()        # eri = ao2mo.incore.full(self._scf._eri, mo_coeff)        # eri = ao2mo.restore(1, eri, nmo)        # eris.oooo = eri[:nocc,:nocc,:nocc,:nocc].copy()        # eris.ovoo = eri[:nocc,nocc:,:nocc,:nocc].copy()        # eris.ovvo = eri[nocc:,:nocc,nocc:,:nocc].copy()        # eris.ovov = eri[nocc:,:nocc,:nocc,nocc:].copy()        # eris.oovv = eri[:nocc,:nocc,nocc:,nocc:].copy()        # ovvv = eri[:nocc,nocc:,nocc:,nocc:].copy()        # eris.ovvv = lib.pack_tril(ovvv.reshape(-1,nvir,nvir))        # eris.vvvv = ao2mo.restore(4, eri[nocc:,nocc:,nocc:,nocc:], nvir)        # eris.fock = np.diag(self._scf.mo_energy)        # return eris        nmo = self.nmo        nao = self.mo_coeff.shape[0]        nmo_pair = nmo * (nmo+1) // 2        nao_pair = nao * (nao+1) // 2        mem_incore = (max(nao_pair**2, nmo**4) + nmo_pair**2) * 8/1e6        mem_now = lib.current_memory()[0]        if (self._scf._eri is not None and            (mem_incore+mem_now < self.max_memory or self.incore_complete)):            return _make_eris_incore(self, mo_coeff)        elif getattr(self._scf, 'with_df', None):            logger.warn(self, 'CCSD detected DF being used in the HF object. '                        'MO integrals are computed based on the DF 3-index tensors.\n'                        'It\'s recommended to use dfccsd.CCSD for the '                        'DF-CCSD calculations')            return _make_df_eris_outcore(self, mo_coeff)        else:            raise NotImplementedError   # should never happen            return _make_eris_outcore(self, mo_coeff)class _ChemistsERIs(ccsd._ChemistsERIs):    def _common_init_(self, mycc, mo_coeff=None):        from pyscf.mp.mp2 import _mo_without_core        mymf = mycc._scf        if mo_coeff is None:            mo_coeff = mycc.mo_coeff        self.mo_coeff = mo_coeff = _mo_without_core(mycc, mo_coeff)# Note: Recomputed fock matrix and HF energy since SCF may not be fully converged.        ''' This block is modified to take precomputed 1e integrals        '''        s1e = getattr(mycc, '_s1e', None)        h1e = getattr(mycc, '_h1e', None)        vhf = getattr(mycc, '_vhf', None)        dm = mymf.make_rdm1(mycc.mo_coeff, mycc.mo_occ)        if vhf is None: vhf = self.get_vhf(mymf, dm, h1e=h1e, s1e=s1e)        fockao = mymf.get_fock(vhf=vhf, dm=dm, h1e=h1e, s1e=s1e)        self.fock = reduce(np.dot, (mo_coeff.conj().T, fockao, mo_coeff))        self.e_hf = mymf.energy_tot(dm=dm, vhf=vhf, h1e=h1e)        nocc = self.nocc = mycc.nocc        self.mol = mycc.mol        # Note self.mo_energy can be different to fock.diagonal().        # self.mo_energy is used in the initial guess function (to generate        # MP2 amplitudes) and CCSD update_amps preconditioner.        # fock.diagonal() should only be used to compute the expectation value        # of Slater determinants.        self.mo_energy = self.fock.diagonal().real        # vhf is assumed to be computed with exxdiv=None and mo_energy is not        # exxdiv-corrected. We add the correction back for MP2 energy if        # mymf.exxdiv is 'ewald'.        # FIXME: Should we correct it for other exxdiv options (e.g., 'vcut_sph')?        if hasattr(mymf, 'exxdiv') and mymf.exxdiv == 'ewald':  # PBC HF object            from pyscf.pbc.cc.ccsd import _adjust_occ            from pyscf.pbc import tools            madelung = tools.madelung(mymf.cell, mymf.kpt)            self.mo_energy = _adjust_occ(self.mo_energy, self.nocc, -madelung)        mo_e = self.mo_energy        try:            gap = abs(mo_e[:nocc,None] - mo_e[None,nocc:]).min()            if gap < 1e-5:                logger.warn(mycc, 'HOMO-LUMO gap %s too small for CCSD.\n'                            'CCSD may be difficult to converge. Increasing '                            'CCSD Attribute level_shift may improve '                            'convergence.', gap)        except ValueError:  # gap.size == 0            pass        return self    def get_vhf(self, mymf, dm, h1e=None, s1e=None):        ''' Build vhf from input dm.        NOTE 1:            If the input dm is the same as the SCF dm, vhf is built directly from the SCF            MO and MO energy; otherwise, scf.get_vhf is called.        NOTE 2:            For PBC, exxdiv = None will be used for building vhf.        '''        dm0 = mymf.make_rdm1()        errdm = abs(dm0-dm).max()        if errdm < 1e-6:            from lno.base.lno import fock_from_mo            if h1e is None: h1e = mymf.get_hcore()            vhf = fock_from_mo(mymf, s1e=s1e, force_exxdiv_none=True) - h1e        else:            if hasattr(mymf, 'exxdiv'):    # PBC CC requires exxdiv=None                with lib.temporary_env(mymf, exxdiv=None):                    vhf = mymf.get_veff(mymf.mol, dm)            else:                vhf = mymf.get_veff(mymf.mol, dm)        return vhfdef _make_eris_incore(mycc, mo_coeff=None):    from pyscf import ao2mo    cput0 = (logger.process_clock(), logger.perf_counter())    eris = _ChemistsERIs()    eris._common_init_(mycc, mo_coeff)    nocc = eris.nocc    nmo = eris.fock.shape[0]    nvir = nmo - nocc    eri1 = ao2mo.incore.full(mycc._scf._eri, eris.mo_coeff)    #:eri1 = ao2mo.restore(1, eri1, nmo)    #:eris.oooo = eri1[:nocc,:nocc,:nocc,:nocc].copy()    #:eris.ovoo = eri1[:nocc,nocc:,:nocc,:nocc].copy()    #:eris.ovvo = eri1[:nocc,nocc:,nocc:,:nocc].copy()    #:eris.ovov = eri1[:nocc,nocc:,:nocc,nocc:].copy()    #:eris.oovv = eri1[:nocc,:nocc,nocc:,nocc:].copy()    #:ovvv = eri1[:nocc,nocc:,nocc:,nocc:].copy()    #:eris.ovvv = lib.pack_tril(ovvv.reshape(-1,nvir,nvir)).reshape(nocc,nvir,-1)    #:eris.vvvv = ao2mo.restore(4, eri1[nocc:,nocc:,nocc:,nocc:], nvir)    if eri1.ndim == 4:        eri1 = ao2mo.restore(4, eri1, nmo)    nvir_pair = nvir * (nvir+1) // 2    eris.oooo = np.empty((nocc,nocc,nocc,nocc))    eris.ovoo = np.empty((nocc,nvir,nocc,nocc))    eris.ovvo = np.empty((nocc,nvir,nvir,nocc))    eris.ovov = np.empty((nocc,nvir,nocc,nvir))    eris.ovvv = np.empty((nocc,nvir,nvir_pair))    eris.vvvv = np.empty((nvir_pair,nvir_pair))    ij = 0    outbuf = np.empty((nmo,nmo,nmo))    oovv = np.empty((nocc,nocc,nvir,nvir))    for i in range(nocc):        buf = lib.unpack_tril(eri1[ij:ij+i+1], out=outbuf[:i+1])        for j in range(i+1):            eris.oooo[i,j] = eris.oooo[j,i] = buf[j,:nocc,:nocc]            oovv[i,j] = oovv[j,i] = buf[j,nocc:,nocc:]        ij += i + 1    eris.oovv = oovv    oovv = None    ij1 = 0    for i in range(nocc,nmo):        buf = lib.unpack_tril(eri1[ij:ij+i+1], out=outbuf[:i+1])        eris.ovoo[:,i-nocc] = buf[:nocc,:nocc,:nocc]        eris.ovvo[:,i-nocc] = buf[:nocc,nocc:,:nocc]        eris.ovov[:,i-nocc] = buf[:nocc,:nocc,nocc:]        eris.ovvv[:,i-nocc] = lib.pack_tril(buf[:nocc,nocc:,nocc:])        dij = i - nocc + 1        lib.pack_tril(buf[nocc:i+1,nocc:,nocc:],                      out=eris.vvvv[ij1:ij1+dij])        ij += i + 1        ij1 += dij    logger.timer(mycc, 'CCSD integral transformation', *cput0)    return erisdef _make_df_eris_outcore(mycc, mo_coeff=None):    from pyscf.ao2mo import _ao2mo    cput0 = (logger.process_clock(), logger.perf_counter())    log = logger.Logger(mycc.stdout, mycc.verbose)    eris = _ChemistsERIs()    eris._common_init_(mycc, mo_coeff)    mo_coeff = np.asarray(eris.mo_coeff, order='F')    nocc = eris.nocc    nao, nmo = mo_coeff.shape    nvir = nmo - nocc    nvir_pair = nvir*(nvir+1)//2    naux = mycc._scf.with_df.get_naoaux()    Loo = np.empty((naux,nocc,nocc))    Lov = np.empty((naux,nocc,nvir))    Lvo = np.empty((naux,nvir,nocc))    Lvv = np.empty((naux,nvir_pair))    ijslice = (0, nmo, 0, nmo)    Lpq = None    p1 = 0    for eri1 in mycc._scf.with_df.loop():        Lpq = _ao2mo.nr_e2(eri1, mo_coeff, ijslice, aosym='s2', out=Lpq).reshape(-1,nmo,nmo)        p0, p1 = p1, p1 + Lpq.shape[0]        Loo[p0:p1] = Lpq[:,:nocc,:nocc]        Lov[p0:p1] = Lpq[:,:nocc,nocc:]        Lvo[p0:p1] = Lpq[:,nocc:,:nocc]        Lvv[p0:p1] = lib.pack_tril(Lpq[:,nocc:,nocc:].reshape(-1,nvir,nvir))    Loo = Loo.reshape(naux,nocc*nocc)    Lov = Lov.reshape(naux,nocc*nvir)    Lvo = Lvo.reshape(naux,nocc*nvir)    eris.feri1 = lib.H5TmpFile()    eris.oooo = eris.feri1.create_dataset('oooo', (nocc,nocc,nocc,nocc), 'f8')    eris.oovv = eris.feri1.create_dataset('oovv', (nocc,nocc,nvir,nvir), 'f8', chunks=(nocc,nocc,1,nvir))    eris.ovoo = eris.feri1.create_dataset('ovoo', (nocc,nvir,nocc,nocc), 'f8', chunks=(nocc,1,nocc,nocc))    eris.ovvo = eris.feri1.create_dataset('ovvo', (nocc,nvir,nvir,nocc), 'f8', chunks=(nocc,1,nvir,nocc))    eris.ovov = eris.feri1.create_dataset('ovov', (nocc,nvir,nocc,nvir), 'f8', chunks=(nocc,1,nocc,nvir))    eris.ovvv = eris.feri1.create_dataset('ovvv', (nocc,nvir,nvir_pair), 'f8')    eris.vvvv = eris.feri1.create_dataset('vvvv', (nvir_pair,nvir_pair), 'f8')    eris.oooo[:] = lib.ddot(Loo.T, Loo).reshape(nocc,nocc,nocc,nocc)    eris.ovoo[:] = lib.ddot(Lov.T, Loo).reshape(nocc,nvir,nocc,nocc)    eris.oovv[:] = lib.unpack_tril(lib.ddot(Loo.T, Lvv)).reshape(nocc,nocc,nvir,nvir)    eris.ovvo[:] = lib.ddot(Lov.T, Lvo).reshape(nocc,nvir,nvir,nocc)    eris.ovov[:] = lib.ddot(Lov.T, Lov).reshape(nocc,nvir,nocc,nvir)    eris.ovvv[:] = lib.ddot(Lov.T, Lvv).reshape(nocc,nvir,nvir_pair)    eris.vvvv[:] = lib.ddot(Lvv.T, Lvv)    log.timer('CCSD integral transformation', *cput0)    return erisclass MODIFIED_DFCCSD(dfccsd.RCCSD):    def ao2mo(self, mo_coeff=None):        return _make_df_eris(self, mo_coeff)class _DFChemistsERIs(_ChemistsERIs):    def _contract_vvvv_t2(self, mycc, t2, direct=False, out=None, verbose=None):        assert(not direct)        return dfccsd._contract_vvvv_t2(mycc, self.mol, self.vvL, t2, out, verbose)def _make_df_eris(cc, mo_coeff=None):    from pyscf.ao2mo import _ao2mo    eris = _DFChemistsERIs()    eris._common_init_(cc, mo_coeff)    nocc = eris.nocc    nmo = eris.fock.shape[0]    nvir = nmo - nocc    nvir_pair = nvir*(nvir+1)//2    with_df = cc.with_df    naux = eris.naux = with_df.get_naoaux()    eris.feri = lib.H5TmpFile()    eris.oooo = eris.feri.create_dataset('oooo', (nocc,nocc,nocc,nocc), 'f8')    eris.ovoo = eris.feri.create_dataset('ovoo', (nocc,nvir,nocc,nocc), 'f8', chunks=(nocc,1,nocc,nocc))    eris.ovov = eris.feri.create_dataset('ovov', (nocc,nvir,nocc,nvir), 'f8', chunks=(nocc,1,nocc,nvir))    eris.ovvo = eris.feri.create_dataset('ovvo', (nocc,nvir,nvir,nocc), 'f8', chunks=(nocc,1,nvir,nocc))    eris.oovv = eris.feri.create_dataset('oovv', (nocc,nocc,nvir,nvir), 'f8', chunks=(nocc,nocc,1,nvir))    # nrow ~ 4e9/8/blockdim to ensure hdf5 chunk < 4GB    chunks = (min(nvir_pair,int(4e8/with_df.blockdim)), min(naux,with_df.blockdim))    eris.vvL = eris.feri.create_dataset('vvL', (nvir_pair,naux), 'f8', chunks=chunks)    Loo = np.empty((naux,nocc,nocc))    Lov = np.empty((naux,nocc,nvir))    mo = np.asarray(eris.mo_coeff, order='F')    ijslice = (0, nmo, 0, nmo)    p1 = 0    Lpq = None    for k, eri1 in enumerate(with_df.loop()):        Lpq = _ao2mo.nr_e2(eri1, mo, ijslice, aosym='s2', mosym='s1', out=Lpq)        p0, p1 = p1, p1 + Lpq.shape[0]        Lpq = Lpq.reshape(p1-p0,nmo,nmo)        Loo[p0:p1] = Lpq[:,:nocc,:nocc]        Lov[p0:p1] = Lpq[:,:nocc,nocc:]        Lvv = lib.pack_tril(Lpq[:,nocc:,nocc:])        eris.vvL[:,p0:p1] = Lvv.T    Lpq = Lvv = None    Loo = Loo.reshape(naux,nocc**2)    #Lvo = Lov.transpose(0,2,1).reshape(naux,nvir*nocc)    Lov = Lov.reshape(naux,nocc*nvir)    eris.oooo[:] = lib.ddot(Loo.T, Loo).reshape(nocc,nocc,nocc,nocc)    eris.ovoo[:] = lib.ddot(Lov.T, Loo).reshape(nocc,nvir,nocc,nocc)    ovov = lib.ddot(Lov.T, Lov).reshape(nocc,nvir,nocc,nvir)    eris.ovov[:] = ovov    eris.ovvo[:] = ovov.transpose(0,1,3,2)    ovov = None    mem_now = lib.current_memory()[0]    max_memory = max(0, cc.max_memory - mem_now)    blksize = max(ccsd.BLKMIN, int((max_memory*.9e6/8-nocc**2*nvir_pair)/(nocc**2+naux)))    oovv_tril = np.empty((nocc*nocc,nvir_pair))    for p0, p1 in lib.prange(0, nvir_pair, blksize):        oovv_tril[:,p0:p1] = lib.ddot(Loo.T, _cp(eris.vvL[p0:p1]).T)    eris.oovv[:] = lib.unpack_tril(oovv_tril).reshape(nocc,nocc,nvir,nvir)    oovv_tril = Loo = None    Lov = Lov.reshape(naux,nocc,nvir)    vblk = max(nocc, int((max_memory*.15e6/8)/(nocc*nvir_pair)))    vvblk = int(min(nvir_pair, 4e8/nocc, max(4, (max_memory*.8e6/8)/(vblk*nocc+naux))))    eris.ovvv = eris.feri.create_dataset('ovvv', (nocc,nvir,nvir_pair), 'f8',                                         chunks=(nocc,1,vvblk))    for q0, q1 in lib.prange(0, nvir_pair, vvblk):        vvL = _cp(eris.vvL[q0:q1])        for p0, p1 in lib.prange(0, nvir, vblk):            tmpLov = _cp(Lov[:,:,p0:p1]).reshape(naux,-1)            eris.ovvv[:,p0:p1,q0:q1] = lib.ddot(tmpLov.T, vvL.T).reshape(nocc,p1-p0,q1-q0)        vvL = None    return erisdef _cp(a):    return np.array(a, copy=False, order='C')''' End of modification of PySCF's CCSD class'''''' impurity solver for LNO-based CCSD/CCSD_T'''def impurity_solve(mf, mo_coeff, lo_coeff, ccsd_t=False, eris=None, frozen=None,                   log=None, verbose_imp=0, tailoredCC=False, ncas=None, nelecas=None):    r''' Solve impurity problem and calculate local correlation energy.    Args:        mo_coeff (np.ndarray):            MOs where the impurity problem is solved.        lo_coeff (np.ndarray):            LOs which the local correlation energy is calculated for.        ccsd_t (bool):            If True, CCSD(T) energy is calculated and returned as the third            item (0 is returned otherwise).        frozen (int or list; optional):            Same syntax as `frozen` in MP2, CCSD, etc.    Return:        e_loc_corr_pt2, e_loc_corr_ccsd, e_loc_corr_ccsd_t:            Local correlation energy at MP2, CCSD, and CCSD(T) level. Note that            the CCSD(T) energy is 0 unless 'ccsd_t' is set to True.    '''    log = logger.new_logger(mf if log is None else log)    cput1 = (logger.process_clock(), logger.perf_counter())    maskocc = mf.mo_occ>1e-10    nocc = np.count_nonzero(maskocc)    nmo = mf.mo_occ.size    frozen, maskact = get_maskact(frozen, nmo)    orbfrzocc = mo_coeff[:,~maskact& maskocc]    orbactocc = mo_coeff[:, maskact& maskocc]    orbactvir = mo_coeff[:, maskact&~maskocc]    orbfrzvir = mo_coeff[:,~maskact&~maskocc]    nfrzocc, nactocc, nactvir, nfrzvir = [orb.shape[1]                                          for orb in [orbfrzocc,orbactocc,                                                      orbactvir,orbfrzvir]]    nlo = lo_coeff.shape[1]    s1e = mf.get_ovlp() if eris is None else eris.s1e    prjlo = fdot(lo_coeff.T, s1e, orbactocc)    log.debug('    impsol:  %d LOs  %d/%d MOs  %d occ  %d vir',              nlo, nactocc+nactvir, nmo, nactocc, nactvir)    # solve impurity problem        if tailoredCC:        mcc_temp = CCSD(mf, mo_coeff=mo_coeff, frozen=frozen).set(verbose=verbose_imp)        cas = mcscf.CASCI(mf, ncas, nelecas)        cas.kernel()        tcc = TCC(mf, cas, mo_coeff=mo_coeff)           mcc = tcc.make_tcc(mcc_temp)    else:        mcc = CCSD(mf, mo_coeff=mo_coeff, frozen=frozen).set(verbose=verbose_imp)    mcc._s1e = s1e    if eris is not None:        mcc._h1e = eris.h1e        mcc._vhf = eris.vhf    imp_eris = mcc.ao2mo()    if isinstance(imp_eris.ovov, np.ndarray):        ovov = imp_eris.ovov    else:        ovov = imp_eris.ovov[()]    oovv = ovov.reshape(nactocc,nactvir,nactocc,nactvir).transpose(0,2,1,3)    ovov = None    cput1 = log.timer_debug1('imp sol - eri    ', *cput1)    # MP2 fragment energy    t1, t2 = mcc.init_amps(eris=imp_eris)[1:]    cput1 = log.timer_debug1('imp sol - mp2 amp', *cput1)    elcorr_pt2 = get_fragment_energy(oovv, t2, prjlo)    cput1 = log.timer_debug1('imp sol - mp2 ene', *cput1)    # CCSD fragment energy    t1, t2 = mcc.kernel(eris=imp_eris, t1=t1, t2=t2)[1:]    cput1 = log.timer_debug1('imp sol - cc  amp', *cput1)    t2 += einsum('ia,jb->ijab',t1,t1)    elcorr_cc = get_fragment_energy(oovv, t2, prjlo)    cput1 = log.timer_debug1('imp sol - cc  ene', *cput1)    if ccsd_t:        from lno.cc.ccsd_t import kernel as CCSD_T        t2 -= einsum('ia,jb->ijab',t1,t1)   # restore t2        elcorr_cc_t = CCSD_T(mcc, imp_eris, prjlo, t1=t1, t2=t2, verbose=verbose_imp)        cput1 = log.timer_debug1('imp sol - cc  (T)', *cput1)    else:        elcorr_cc_t = 0.    frag_msg = '  '.join([f'E_corr(MP2) = {elcorr_pt2:.15g}',                          f'E_corr(CCSD) = {elcorr_cc:.15g}',                          f'E_corr(CCSD(T)) = {elcorr_cc_t:.15g}'])    t1 = t2 = oovv = imp_eris = mcc = None    return frag_msg, (elcorr_pt2, elcorr_cc, elcorr_cc_t)def get_maskact(frozen, nmo):    # Convert frozen to 0 bc PySCF solvers do not support frozen=None or empty list    if frozen is None:        frozen = 0    elif isinstance(frozen, (list,tuple,np.ndarray)) and len(frozen) == 0:        frozen = 0    if isinstance(frozen, (int,np.integer)):        maskact = np.hstack([np.zeros(frozen,dtype=bool),                             np.ones(nmo-frozen,dtype=bool)])    elif isinstance(frozen, (list,tuple,np.ndarray)):        maskact = np.array([i not in frozen for i in range(nmo)])    else:        raise RuntimeError    return frozen, maskactdef get_fragment_energy(oovv, t2, prj):    m = fdot(prj.T, prj)    return einsum('ijab,kjab,ik->',t2,2*oovv-oovv.transpose(0,1,3,2),m)class TCC(ccsd.CCSD):    def __init__(self, mf, cas, frozen=None, mo_coeff=None, mo_occ=None):        super().__init__(mf, frozen, mo_coeff, mo_occ)        self.mf = mf        self.cas = cas         self.frozen = frozen        self.mo_coeff = mo_coeff        self.mo_occ = mo_occ        def make_tcc(self, tcc):        '''        Return: ccsd object with TCC        '''        einsum = partial(np.einsum, optimize=True)        nelec_cas = sum(self.cas.nelecas)        nocc_cas = nelec_cas//2        # mo_cc = _mo_without_core(tcc, self.mo_coeff) # incorrect but runs        mo_cc = _mo_without_core(tcc, tcc.mo_coeff) # doesn't run for method 2        nocc_cc = tcc.get_nocc()        mo_cc_occ = mo_cc[:,:nocc_cc]        mo_cc_vir = mo_cc[:,nocc_cc:]        mo_cas = self.cas.mo_coeff[:,self.cas.ncore:self.cas.ncore+self.cas.ncas]        mo_cas_occ = mo_cas[:,:nocc_cas]        mo_cas_vir = mo_cas[:,nocc_cas:]        ovlp = tcc._scf.get_ovlp()        pocc = np.linalg.multi_dot((mo_cc_occ.T, ovlp, mo_cas_occ))        pvir = np.linalg.multi_dot((mo_cc_vir.T, ovlp, mo_cas_vir))        def get_cas_t1t2(cas):            """Get T1 and T2 amplitudes from FCI wave function."""            cisdvec = pyscf.ci.cisd.from_fcivec(cas.ci, cas.ncas, nelec_cas)            c0, c1, c2 = ci.cisd.cisdvec_to_amplitudes(cisdvec, cas.ncas, nocc_cas)            assert (abs(c0) > 1e-8)            t1 = c1/c0            t2 = c2/c0 - einsum('ia,jb->ijab', t1, t1)            return t1, t2        t1cas_fci, t2cas_fci = get_cas_t1t2(self.cas)        def callback(kwargs):            """Tailor CCSD amplitudes within CAS."""            t1, t2 = kwargs['t1new'], kwargs['t2new']            # Project CCSD amplitudes onto CAS:            t1cas_cc = einsum('IA,Ii,Aa->ia', t1, pocc, pvir)            t2cas_cc = einsum('IJAB,Ii,Jj,Aa,Bb->ijab', t2, pocc, pocc, pvir, pvir)            # Take difference FCI-CCSD within CAS:            dt1 = (t1cas_fci - t1cas_cc)            dt2 = (t2cas_fci - t2cas_cc)            # Rotate difference to CCSD space:            dt1 = einsum('ia,Ii,Aa->IA', dt1, pocc, pvir)            dt2 = einsum('ijab,Ii,Jj,Aa,Bb->IJAB', dt2, pocc, pocc, pvir, pvir)            # Add difference:            t1 += dt1            t2 += dt2        tcc.callback = callback        return tccclass LNOCCSD(LNO):    def __init__(self, mf, thresh=1e-6, frozen=None, run_tcc=False, ncas=None, nelecas=None):        LNO.__init__(self, mf, thresh=thresh, frozen=frozen)        self.efrag_cc = None        self.efrag_pt2 = None        self.efrag_cc_t = None        self.ccsd_t = False        self.run_tcc = run_tcc        self.ncas = ncas        self.nelecas = nelecas    def dump_flags(self, verbose=None):        LNO.dump_flags(self, verbose=verbose)        return self    def impurity_solve(self, mf, mo_coeff, lo_coeff, eris=None, frozen=None, log=None):        self.mo_coeff=mo_coeff        return impurity_solve(mf, mo_coeff, lo_coeff, eris=eris, frozen=frozen, log=log,                              verbose_imp=self.verbose_imp, ccsd_t=self.ccsd_t, tailoredCC=self.run_tcc,                               ncas=self.ncas, nelecas=self.nelecas)    def _post_proc(self, frag_res, frag_wghtlist):        ''' Post processing results returned by `impurity_solve` collected in `frag_res`.        '''        nfrag = len(frag_res)        efrag_pt2 = np.zeros(nfrag)        efrag_cc = np.zeros(nfrag)        efrag_cc_t = np.zeros(nfrag)        for i in range(nfrag):            efrag_pt2[i], efrag_cc[i], efrag_cc_t[i] = frag_res[i]        self.efrag_pt2  = efrag_pt2  * frag_wghtlist        self.efrag_cc   = efrag_cc   * frag_wghtlist        self.efrag_cc_t = efrag_cc_t * frag_wghtlist    def _finalize(self):        r''' Hook for dumping results and clearing up the object.'''        logger.note(self, 'E(%s) = %.15g  E_corr = %.15g',                    'LNOMP2', self.e_tot_pt2, self.e_corr_pt2)        logger.note(self, 'E(%s) = %.15g  E_corr = %.15g',                    'LNOCCSD', self.e_tot, self.e_corr)        if self.ccsd_t:            logger.note(self, 'E(%s) = %.15g  E_corr = %.15g',                        'LNOCCSD_T', self.e_tot_ccsd_t, self.e_corr_ccsd_t)        return self    @property    def e_corr(self):        return self.e_corr_ccsd    @property    def e_corr_ccsd(self):        e_corr = np.sum(self.efrag_cc)        return e_corr    @property    def e_corr_pt2(self):        e_corr = np.sum(self.efrag_pt2)        return e_corr    @property    def e_corr_ccsd_t(self):        e_corr = np.sum(self.efrag_cc_t)        return e_corr    @property    def e_tot_ccsd(self):        return self.e_corr_ccsd + self._scf.e_tot    @property    def e_tot_pt2(self):        return self.e_corr_pt2 + self._scf.e_tot    def e_corr_pt2corrected(self, ept2):        return self.e_corr - self.e_corr_pt2 + ept2    def e_tot_pt2corrected(self, ept2):        return self._scf.e_tot + self.e_corr_pt2corrected(ept2)    def e_corr_ccsd_pt2corrected(self, ept2):        return self.e_corr_ccsd - self.e_corr_pt2 + ept2    def e_tot_ccsd_pt2corrected(self, ept2):        return self._scf.e_tot_ccsd + self.e_corr_pt2corrected(ept2)    def e_corr_ccsd_t_pt2corrected(self, ept2):        return self.e_corr_ccsd_t - self.e_corr_pt2 + ept2    def e_tot_ccsd_t_pt2corrected(self, ept2):        return self._scf.e_tot_ccsd_t + self.e_corr_pt2corrected(ept2)class LNOCCSD_T(LNOCCSD):    def __init__(self, mf, thresh=1e-6, frozen=None):        LNOCCSD.__init__(self, mf, thresh=thresh, frozen=frozen)        self.ccsd_t = Trueif __name__ == '__main__':    from pyscf import gto, scf, mp, cc    log = logger.Logger(sys.stdout, 6)    # S22-2: water dimer    atom = ''' O   -1.485163346097   -0.114724564047    0.000000000000 H   -1.868415346097    0.762298435953    0.000000000000 H   -0.533833346097    0.040507435953    0.000000000000 O    1.416468653903    0.111264435953    0.000000000000 H    1.746241653903   -0.373945564047   -0.758561000000 H    1.746241653903   -0.373945564047    0.758561000000'''    basis = 'cc-pvdz'    mol = gto.M(atom=atom, basis=basis)    mol.verbose = 4    mf = scf.RHF(mol).density_fit()    mf.kernel()    frozen = 2# canonical    mmp = mp.MP2(mf, frozen=frozen)    mmp.kernel()    mcc = cc.CCSD(mf, frozen=frozen).set(verbose=5)    eris = mcc.ao2mo()    mcc.kernel(eris=eris)    from pyscf.cc.ccsd_t import kernel as CCSD_T    eccsd_t = CCSD_T(mcc, eris)# LNO    for thresh in [1e-3, 1e-4, 1e-5]:        mfcc = LNOCCSD(mf, thresh=thresh, frozen=frozen).set(verbose=5)        mfcc.thresh_occ = 1e-3        mfcc.thresh_vir = thresh        mfcc.lo_type = 'pm'        mfcc.no_type = 'cim'        mfcc.frag_lolist = '1o'        mfcc.force_outcore_ao2mo = True        mfcc.kernel()        ecc = mfcc.e_corr        ecc_pt2corrected = mfcc.e_corr_pt2corrected(mmp.e_corr)        ecc_t = mfcc.e_corr_ccsd_t        log.info('thresh = %.0e  E_corr(CCSD)     = %.10f  rel = %6.2f%%  '                 'diff = % .10f',                 thresh, ecc, ecc/mcc.e_corr*100, ecc-mcc.e_corr)        log.info('                E_corr(CCSD+PT2) = %.10f  rel = %6.2f%%  '                 'diff = % .10f',                 ecc_pt2corrected, ecc_pt2corrected/mcc.e_corr*100,                 ecc_pt2corrected-mcc.e_corr)        log.info('                E_corr(CCSD_T)   = %.10f  rel = %6.2f%%  '                 'diff = % .10f',                 ecc_t, ecc_t/eccsd_t*100, ecc_t-eccsd_t)