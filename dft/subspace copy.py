#!/usr/bin/env python3# -*- coding: utf-8 -*-"""pseudo.pyImplements Manby & Miller Projection Based Embedding withot a level-shiftingoperator by diagonalizing the Fock matrix only within the active block. (subspace SCF)author: Ardavan Farahvash, github.com/afarahva"""import numpy as npfrom scipy.linalg import eighfrom pyscf_embedding import libfrom pyscf.lib import logger, NPArrayWithTag, diisfrom pyscf import scf, dft, mp, cc, dffrom pyscf import __config__TIGHT_GRAD_CONV_TOL = getattr(__config__, 'scf_hf_kernel_tight_grad_conv_tol', True)def mk_huzinaga_kernel(hcore, dm_B):    import numpy     from pyscf.lib import diis    from pyscf.scf import chkfile        def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,               dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):            cput0 = (logger.process_clock(), logger.perf_counter())        if conv_tol_grad is None:            conv_tol_grad = numpy.sqrt(conv_tol)            logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)            mol = mf.mol        s1e = mf.get_ovlp(mol)            if dm0 is None:            dm = mf.get_init_guess(mol, mf.init_guess, s1e=s1e, **kwargs)        else:            dm = dm0            h1e = mf.get_hcore(mol)        vhf = mf.get_veff(mol, dm)        e_tot = mf.energy_tot(dm, h1e, vhf)        logger.info(mf, 'init E= %.15g', e_tot)            scf_conv = False        mo_energy = mo_coeff = mo_occ = None            # Skip SCF iterations. Compute only the total energy of the initial density        if mf.max_cycle <= 0:            fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS            mo_energy, mo_coeff = mf.eig(fock, s1e)            mo_occ = mf.get_occ(mo_energy, mo_coeff)            return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ            if isinstance(mf.diis, diis.DIIS):            mf_diis = mf.diis        elif mf.diis:            assert issubclass(mf.DIIS, diis.DIIS)            mf_diis = mf.DIIS(mf, mf.diis_file)            mf_diis.space = mf.diis_space            mf_diis.rollback = mf.diis_space_rollback            mf_diis.damp = mf.diis_damp                # We get the used orthonormalized AO basis from any old eigendecomposition.            # Since the ingredients for the Fock matrix has already been built, we can            # just go ahead and use it to determine the orthonormal basis vectors.            fock = mf.get_fock(h1e, s1e, vhf, dm)            _, mf_diis.Corth = mf.eig(fock, s1e)        else:            mf_diis = None            if dump_chk and mf.chkfile:            # Explicit overwrite the mol object in chkfile            # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"            chkfile.save_mol(mol, mf.chkfile)            # A preprocessing hook before the SCF iteration        mf.pre_kernel(locals())            fock_last = None        cput1 = logger.timer(mf, 'initialize scf', *cput0)        mf.cycles = 0        for cycle in range(mf.max_cycle):            dm_last = dm            last_hf_e = e_tot                fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis, fock_last=fock_last)            mo_energy, mo_coeff = mf.eig(fock, s1e)            mo_occ = mf.get_occ(mo_energy, mo_coeff)            dm = mf.make_rdm1(mo_coeff, mo_occ)            vhf = mf.get_veff(mol, dm, dm_last, vhf)            e_tot = mf.energy_tot(dm, h1e, vhf)                        m = 0.5*(vhf + hcore) @ dm_B @ s1e            h1e = hcore - m - m.T                # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock            # instead of the statement "fock = h1e + vhf" because Fock matrix may            # be modified in some methods.            fock_last = fock            fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS            norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))            if not TIGHT_GRAD_CONV_TOL:                norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)            norm_ddm = numpy.linalg.norm(dm-dm_last)            logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                        cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)                if callable(mf.check_convergence):                scf_conv = mf.check_convergence(locals())            elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:                scf_conv = True                if dump_chk and mf.chkfile:                mf.dump_chk(locals())                if callable(callback):                callback(locals())                cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)                if scf_conv:                break            mf.cycles = cycle + 1        if scf_conv and conv_check:            # An extra diagonalization, to remove level shift            #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf            mo_energy, mo_coeff = mf.eig(fock, s1e)            mo_occ = mf.get_occ(mo_energy, mo_coeff)            dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm            vhf = mf.get_veff(mol, dm, dm_last, vhf)            e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot                fock = mf.get_fock(h1e, s1e, vhf, dm)            norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))            if not TIGHT_GRAD_CONV_TOL:                norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)            norm_ddm = numpy.linalg.norm(dm-dm_last)                conv_tol = conv_tol * 10            conv_tol_grad = conv_tol_grad * 3            if callable(mf.check_convergence):                scf_conv = mf.check_convergence(locals())            elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:                scf_conv = True            logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                        e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)            if dump_chk and mf.chkfile:                mf.dump_chk(locals())            logger.timer(mf, 'scf_cycle', *cput0)        # A post-processing hook before return        mf.post_kernel(locals())        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ        return kerneldef kernel1(mf, hcore, huzinaga, dm, conv_tol=1e-10, conv_tol_grad=None,           dump_chk=True, callback=None, conv_check=True):        from pyscf.lib import diis as libdiis    from pyscf.scf import chkfile    cput0 = (logger.process_clock(), logger.perf_counter())    if conv_tol_grad is None:        conv_tol_grad = np.sqrt(conv_tol)        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)    mol = mf.mol    s1e = mf.get_ovlp(mol)    h1e = hcore + huzinaga    vhf = mf.get_veff(mol, dm)    e_tot = mf.energy_tot(dm, h1e, vhf)    logger.info(mf, 'init E= %.15g', e_tot)    scf_conv = False    mo_energy = mo_coeff = mo_occ = None    if isinstance(mf.diis, libdiis.DIIS):        mf_diis = mf.diis    elif mf.diis:        assert issubclass(mf.DIIS, libdiis.DIIS)        mf_diis = mf.DIIS(mf, mf.diis_file)        mf_diis.space = mf.diis_space        mf_diis.rollback = mf.diis_space_rollback        mf_diis.damp = mf.diis_damp        # We get the used orthonormalized AO basis from any old eigendecomposition.        # Since the ingredients for the Fock matrix has already been built, we can        # just go ahead and use it to determine the orthonormal basis vectors.        fock = mf.get_fock(h1e, s1e, vhf, dm)        _, mf_diis.Corth = mf.eig(fock, s1e)    else:        mf_diis = None    if dump_chk and mf.chkfile:        # Explicit overwrite the mol object in chkfile        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"        chkfile.save_mol(mol, mf.chkfile)    # A preprocessing hook before the SCF iteration    mf.pre_kernel(locals())    fock_last = None    cput1 = logger.timer(mf, 'initialize scf', *cput0)    mf.cycles = 0    for cycle in range(mf.max_cycle):        dm_last = dm        last_hf_e = e_tot        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis, fock_last=fock_last)        mo_energy, mo_coeff = mf.eig(fock, s1e)        mo_occ = mf.get_occ(mo_energy, mo_coeff)        dm = mf.make_rdm1(mo_coeff, mo_occ)        vhf = mf.get_veff(mol, dm, dm_last, vhf)        e_tot = mf.energy_tot(dm, h1e, vhf)        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock        # instead of the statement "fock = h1e + vhf" because Fock matrix may        # be modified in some methods.        fock_last = fock        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))        if not TIGHT_GRAD_CONV_TOL:            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)        norm_ddm = np.linalg.norm(dm-dm_last)        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)        if callable(mf.check_convergence):            scf_conv = mf.check_convergence(locals())        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:            scf_conv = True        if dump_chk and mf.chkfile:            mf.dump_chk(locals())        if callable(callback):            callback(locals())        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)        if scf_conv:            break    logger.timer(mf, 'scf_cycle', *cput0)    # A post-processing hook before return    mf.post_kernel(locals())    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occdef kernel2(mf, hcore, huzinaga, dm, dm_B, conv_tol=1e-10, conv_tol_grad=None,           dump_chk=True, callback=None, conv_check=True):        from pyscf.lib import diis as libdiis    from pyscf.scf import chkfile    cput0 = (logger.process_clock(), logger.perf_counter())    if conv_tol_grad is None:        conv_tol_grad = np.sqrt(conv_tol)        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)    mol = mf.mol    s1e = mf.get_ovlp(mol)    h1e = hcore + huzinaga#mf.get_hcore(mol)     vhf = mf.get_veff(mol, dm)    e_tot = mf.energy_tot(dm, h1e, vhf)    logger.info(mf, 'init E= %.15g', e_tot)    scf_conv = False    mo_energy = mo_coeff = mo_occ = None    if isinstance(mf.diis, libdiis.DIIS):        mf_diis = mf.diis    elif mf.diis:        assert issubclass(mf.DIIS, libdiis.DIIS)        mf_diis = mf.DIIS(mf, mf.diis_file)        mf_diis.space = mf.diis_space        mf_diis.rollback = mf.diis_space_rollback        mf_diis.damp = mf.diis_damp        # We get the used orthonormalized AO basis from any old eigendecomposition.        # Since the ingredients for the Fock matrix has already been built, we can        # just go ahead and use it to determine the orthonormal basis vectors.        fock = mf.get_fock(h1e, s1e, vhf, dm)        _, mf_diis.Corth = mf.eig(fock, s1e)    else:        mf_diis = None    if dump_chk and mf.chkfile:        # Explicit overwrite the mol object in chkfile        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"        chkfile.save_mol(mol, mf.chkfile)    # A preprocessing hook before the SCF iteration    mf.pre_kernel(locals())    fock_last = None    cput1 = logger.timer(mf, 'initialize scf', *cput0)    mf.cycles = 0    for cycle in range(mf.max_cycle):        dm_last = dm        last_hf_e = e_tot        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis, fock_last=fock_last)        mo_energy, mo_coeff = mf.eig(fock, s1e)        mo_occ = mf.get_occ(mo_energy, mo_coeff)        dm = mf.make_rdm1(mo_coeff, mo_occ)        vhf = mf.get_veff(mol, dm, dm_last, vhf)        e_tot = mf.energy_tot(dm, h1e, vhf)                m = 0.5*(vhf + hcore) @ dm_B @ s1e        h1e = hcore - m - m.T        # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock        # instead of the statement "fock = h1e + vhf" because Fock matrix may        # be modified in some methods.        fock_last = fock        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))        if not TIGHT_GRAD_CONV_TOL:            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)        norm_ddm = np.linalg.norm(dm-dm_last)        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)        if callable(mf.check_convergence):            scf_conv = mf.check_convergence(locals())        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:            scf_conv = True        if dump_chk and mf.chkfile:            mf.dump_chk(locals())        if callable(callback):            callback(locals())        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)        if scf_conv:            break    logger.timer(mf, 'scf_cycle', *cput0)    # A post-processing hook before return    mf.post_kernel(locals())    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ     #%%if __name__ == '__main__':    import matplotlib.pyplot as plt    import pyscf    from pyscf.tools import cubegen    from pyscf_embedding.dmet import regional as re    from pyscf.scf import hf, RKS        coords = \    """    O         -3.65830        0.00520       -0.94634    H         -4.10550        1.27483       -1.14033    C         -2.05632        0.04993       -0.35355    C         -1.42969        1.27592       -0.14855    C         -0.12337        1.31114        0.33487    C          0.54981        0.12269        0.61082    C         -0.08157       -1.10218        0.40403    C         -1.38785       -1.13991       -0.07931    H         -1.93037        2.15471       -0.35367    H          0.34566        2.21746        0.48856    H          1.51734        0.14971        0.96884    H          0.41837       -1.98145        0.60889    H         -1.85763       -2.04579       -0.23330    """        #%%    ##### Run supersystem MF, method 1    mol = pyscf.M(atom=coords,basis='sto-3g',verbose=4)    mf = mol.RHF(max_cycles=100).run()    # mf = mol.RKS(xc='pbe').run()    e_tot_hf = mf.e_tot.copy()    ##### Partition MOs        e_tot_arr = []    orb_arr= []    for i in range(1,2):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')                moE_occ,moC_occ,mask_occ_act = occ_calc.calc_mo()        moC_occ_act = moC_occ[:,mask_occ_act]        moC_occ_frz = moC_occ[:,~mask_occ_act]        print(np.sum(mask_occ_act))        Nocc_act = occ_calc.Norb_act        Nocc_frz = np.sum(~mask_occ_act)                moC_A = np.hstack([moC_occ_act,mf.mo_coeff[:,mf.mo_occ==0]])        moO_A = np.array( [0]*(np.sum(mf.mo_occ==0)+Nocc_act) )        moO_A[0:Nocc_act] = 2                   moC_B = moC_occ_frz        moO_B = np.array( [2] * Nocc_frz)                # partition density matrices        dm_A = mf.make_rdm1(moC_A, moO_A)        dm_B = mf.make_rdm1(moC_B, moO_B)                    ##### Test new kernel function        mf_B = mf.copy()                mf_A = mol.RKS(xc='b3lyp')        mf_A.diis=True        mf_A.mol.nelectron = int(2 * Nocc_act)                fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)        huzinaga = mf_B.get_fock(dm=dm_A+dm_B)  @ dm_B @ mf_A.get_ovlp()        huzinaga = -0.5*(huzinaga + huzinaga.T)            mf_A.max_cycle=30        scf_conv, e_tot, mo_energy, mo_coeff, mo_occ = kernel1(mf_A, fock_core, huzinaga, dm_A)                # test orthogonality        orth = mo_coeff[:,0].T @ mf.get_ovlp() @ moC_B        print( np.linalg.norm(orth))                #        e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]        # print(e_tot)        e_tot_arr.append(e_full)        orb_arr.append(Nocc_act)            plt.figure()    plt.plot(e_tot_arr-e_tot_hf,linewidth=2.0)    plt.xlabel("# of active occupied orbitals")    plt.ylabel("$E_c$ (hartree)")    plt.legend(frameon=False)        #%%    ##### Run supersystem MF, method 2    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RHF(max_cycles=100).run()    e_tot_hf = mf.e_tot.copy()        ##### Partition MOs        e_tot_arr = []    orb_arr= []    for i in range(1,2):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        moE_occ,moC_occ,mask_occ_act = occ_calc.calc_mo()        moC_occ_act = moC_occ[:,mask_occ_act]        moC_occ_frz = moC_occ[:,~mask_occ_act]        print(np.sum(mask_occ_act))        Nocc_act = occ_calc.Norb_act        Nocc_frz = np.sum(~mask_occ_act)                moC_A = np.hstack([moC_occ_act,mf.mo_coeff[:,mf.mo_occ==0]])        moO_A = np.array( [0]*(np.sum(mf.mo_occ==0)+Nocc_act) )        moO_A[0:Nocc_act] = 2                   moC_B = moC_occ_frz        moO_B = np.array( [2] * Nocc_frz)                # partition density matrices        dm_A = mf.make_rdm1(moC_A, moO_A)        dm_B = mf.make_rdm1(moC_B, moO_B)                    ##### Test new kernel function        mf_B = mf.copy()                # mf_A = mol.RHF()        mf_A = mol.RKS(xc='pbe')        mf_A.diis=True        mf_A.mol.nelectron = int(2 * Nocc_act)                fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)        huzinaga = fock_core  @ dm_B @ mf_A.get_ovlp()        huzinaga = -0.5*(huzinaga + huzinaga.T )#+ mf_A.get_ovlp() @ dm_B @ fock_core  @ dm_B @ mf_A.get_ovlp())            mf_A.max_cycle=30        scf_conv, e_tot, mo_energy, mo_coeff, mo_occ = kernel2(mf_A, fock_core, huzinaga, dm_A, dm_B)                # test orthogonality        orth = np.linalg.norm(mo_coeff.T @ mf.get_ovlp() @ moC_B,axis=1) # check to see which orbitals are orthogonal to the         print(orth)        #        e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]        # print(e_tot)        e_tot_arr.append(e_full)        orb_arr.append(Nocc_act)        print(e_full)            plt.figure()    plt.plot(e_tot_arr-e_tot_hf,linewidth=2.0)    plt.xlabel("# of active occupied orbitals")    plt.ylabel("$E_c$ (hartree)")    plt.legend(frameon=False)        #%%    ##### Run supersystem MF, method 3    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RHF(max_cycles=100).run()    e_tot_hf = mf.e_tot.copy()        ##### Partition MOs        e_tot_arr = []    orb_arr= []    for i in range(1,10):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        moE_occ,moC_occ,mask_occ_act = occ_calc.calc_mo()        moC_occ_act = moC_occ[:,mask_occ_act]        moC_occ_frz = moC_occ[:,~mask_occ_act]        print(np.sum(mask_occ_act))        Nocc_act = occ_calc.Norb_act        Nocc_frz = np.sum(~mask_occ_act)                moC_A = np.hstack([moC_occ_act,mf.mo_coeff[:,mf.mo_occ==0]])        moO_A = np.array( [0]*(np.sum(mf.mo_occ==0)+Nocc_act) )        moO_A[0:Nocc_act] = 2                   moC_B = moC_occ_frz        moO_B = np.array( [2] * Nocc_frz)                # partition density matrices        dm_A = mf.make_rdm1(moC_A, moO_A)        dm_B = mf.make_rdm1(moC_B, moO_B)                    ##### Test new kernel function        mf_B = mf.copy()                mf_A = mol.RKS(xc='b3lyp')        mf_A.diis=True        mf_A.mol.nelectron = int(2 * Nocc_act)                fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)        huzinaga = fock_core  @ dm_B @ mf_A.get_ovlp()        huzinaga = -0.5*(huzinaga + huzinaga.T)            mf_A.max_cycle=30        mf_A.get_hcore = lambda *args: fock_core + huzinaga        e_tot = mf_A.kernel()                # test orthogonality        orth = mo_coeff[:,0].T @ mf.get_ovlp() @ moC_B        print(orth)                #        e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]        # print(e_tot)        e_tot_arr.append(e_full)        orb_arr.append(Nocc_act)                plt.figure()        plt.plot(e_tot_arr-e_tot_hf,linewidth=2.0)        plt.xlabel("# of active occupied orbitals")        plt.ylabel("$E_c$ (hartree)")        plt.legend(frameon=False)        #%%    ##### Run supersystem MF, method 4    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RHF(max_cycles=100).run()    e_tot_hf = mf.e_tot.copy()        ##### Partition MOs        e_tot_arr = []    orb_arr= []    for i in range(1,10):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        moE_occ,moC_occ,mask_occ_act = occ_calc.calc_mo()        moC_occ_act = moC_occ[:,mask_occ_act]        moC_occ_frz = moC_occ[:,~mask_occ_act]        print(np.sum(mask_occ_act))        Nocc_act = occ_calc.Norb_act        Nocc_frz = np.sum(~mask_occ_act)                moC_A = np.hstack([moC_occ_act,mf.mo_coeff[:,mf.mo_occ==0]])        moO_A = np.array( [0]*(np.sum(mf.mo_occ==0)+Nocc_act) )        moO_A[0:Nocc_act] = 2                   moC_B = moC_occ_frz        moO_B = np.array( [2] * Nocc_frz)                # partition density matrices        dm_A = mf.make_rdm1(moC_A, moO_A)        dm_B = mf.make_rdm1(moC_B, moO_B)                    ##### Test new kernel function        mf_B = mf.copy()                mf_A = mol.RKS(xc='b3lyp')        mf_A.diis=True        mf_A.mol.nelectron = int(2 * Nocc_act)                fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)        huzinaga = fock_core  @ dm_B @ mf_A.get_ovlp()        huzinaga = -0.5*(huzinaga + huzinaga.T)            mf_A.max_cycle=30        mf_A.get_hcore = lambda *args: fock_core+huzinaga        mf_A.kernel = mk_huzinaga_kernel(fock_core,dm_B).__get__(mf_A,type(mf_A))        _,e_tot,_,_,_ = mf_A.kernel(dm0=dm_A)                # test orthogonality        orth = mo_coeff[:,0].T @ mf.get_ovlp() @ moC_B        print(orth)                #        e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]        # print(e_tot)        e_tot_arr.append(e_full)        orb_arr.append(Nocc_act)            plt.figure()    plt.plot(e_tot_arr-e_tot_hf,linewidth=2.0)    plt.xlabel("# of active occupied orbitals")    plt.ylabel("$E_c$ (hartree)")    plt.legend(frameon=False)    #%%    # dynamic projection    def wrapper(P):        '''Solver for generalized eigenvalue problem            .. math:: HC = SCE        '''        def eig(h,s):            if P is None:                e, c = eigh(h, s)            else:                h_new = P.T @ h @ P                s_new = P.T @ s @ P                e,c = eigh(h_new,s_new)                c = P @ c                            idx = np.argmax(abs(c.real), axis=0)            c[:,c[idx,np.arange(len(e))].real<0] *= -1            return e,c        return eig        mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='pbe').run()    e_tot_hf = mf.e_tot.copy()        ##### Partition MOs        e_tot_arr = []    orb_arr= []    for i in range(1,10):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        moE_occ,moC_occ,mask_occ_act = occ_calc.calc_mo()        moC_occ_act = moC_occ[:,mask_occ_act]        moC_occ_frz = moC_occ[:,~mask_occ_act]                Nocc_act = occ_calc.Norb_act        Nocc_frz = np.sum(~mask_occ_act)                moC_A = np.hstack([moC_occ_act,mf.mo_coeff[:,mf.mo_occ==0]])        moO_A = np.array( [0]*(np.sum(mf.mo_occ==0)+Nocc_act) )        moO_A[0:Nocc_act] = 2                   moC_B = moC_occ_frz        moO_B = np.array( [2] * Nocc_frz)                # partition density matrices        dm_A = mf.make_rdm1(moC_A, moO_A)        dm_B = mf.make_rdm1(moC_B, moO_B)            mf_B = mf.copy()        mf_A = mol.RKS(xc='b3lyp')        mf_A.diis=True        mf_A.eig = wrapper(P=moC_A)        mf_A.mol.nelectron = int(2 * Nocc_act)                fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)        huzinaga = fock_core  @ dm_B @ mf_A.get_ovlp()        huzinaga = -(huzinaga + huzinaga.T)        mf_A.get_hcore = lambda *args: fock_core#+huzinaga        mf_A.max_cycle=30        scf_conv, e_tot, mo_energy, mo_coeff, mo_occ = kernel1(mf_A, fock_core, huzinaga, dm_A)                mf_A.mo_coeff = mo_coeff        mf_A.mo_occ = mo_occ        mf_A.mo_energy = mo_energy        mf_A.converged = True        mf_A.e_tot = -306.98039463001004                orth = mo_coeff[:,0].T @ mf.get_ovlp() @ moC_B        e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]        e_tot_arr.append(e_full)        orb_arr.append(Nocc_act)        plt.figure()    plt.plot(e_tot_arr-e_tot_hf,linewidth=2.0)    plt.xlabel("# of active occupied orbitals")    plt.ylabel("$E_c$ (hartree)")    plt.legend(frameon=False)        #%%    # # dynamic projection        # from pyscf_embedding.localorbs.lib import rActiveSpaceEmbedding        # def wrapper(occ_calc, occ_args, occ_kwargs, vir_calc, vir_args, vir_kwargs):    #     '''Solver for generalized eigenvalue problem        #     .. math:: HC = SCE    #     '''    #     def eig(mf, h, s):                #         mo_energy, mo_coeff = eigh(h, s)    #         mf.mo_energy = mo_energy    #         mf.mo_coeff = mo_coeff    #         mf.mo_occ = mf.get_occ()                #         occ_calc.__init__(mf,*occ_args,**occ_kwargs)    #         vir_calc.__init__(mf,*occ_args,**occ_kwargs)    #         embed = rActiveSpaceEmbedding(occ_calc,vir_calc)    #         embed.kernel()                #         mo_energy = embed.moE_proj[embed.mask_act]    #         mo_coeff = embed.moC_proj[:,embed.mask_act]    #         return mo_energy, mo_coeff    #     return eig        # mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    # mf = mol.RHF(max_cycles=100).run()    # e_tot_hf = mf.e_tot.copy()        # ##### Partition MOs        # e_tot_arr = []    # orb_arr= []    # for i in range(1,10):    #     occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')    #     vir_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'vir', basis='minao')    #     mf_A = mol.RKS(xc='b3lyp')    #     mf_A.eig = wrapper(P=moC_A)    #     mf_A.mol.nelectron = int(2 * Nocc_act)            #     fock_core = mf_B.get_fock(dm=dm_A+dm_B) - mf_B.get_veff(dm=dm_A)    #     huzinaga = fock_core  @ dm_B @ mf_A.get_ovlp()    #     huzinaga = -(huzinaga + huzinaga.T)        #     mf_A.max_cycle=20    #     scf_conv, e_tot, mo_energy, mo_coeff, mo_occ = kernel1(mf_A, fock_core, huzinaga, dm_A)            #     orth = mo_coeff[:,0].T @ mf.get_ovlp() @ moC_B    #     e_full = mf_B.energy_elec(dm=dm_A+dm_B)[0] + e_tot - mf_B.energy_elec(dm=dm_A,h1e=fock_core+huzinaga)[0]    #     e_tot_arr.append(e_full)    #     orb_arr.append(Nocc_act)        # plt.figure()    # plt.plot(orb_arr,e_tot_arr-e_tot_hf,linewidth=2.0)    # plt.xlabel("# of active occupied orbitals")    # plt.ylabel("$E_c$ (hartree)")    # plt.legend(frameon=False)