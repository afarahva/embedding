#!/usr/bin/env python3# -*- coding: utf-8 -*-"""fixed_density.pyProjection Based Embedding without a level-shift operator using a fixed densityapproximation for the embedded orbital spaceauthor: Ardavan Farahvash, github.com/afarahva"""import numpy as npfrom pyscf_embedding.dft import prbefrom pyscf import scf, dft, dfclass rFixedDensity(prbe.rPRBE):    def kernel(self, xc_embed=None, **kwargs):                mf_B = self.mf_B                # copy input mf        ovlp = mf_B.get_ovlp()        mol = mf_B.mol.copy()                # build embedding potential and effective core potential        dm_A = self.make_rdmA_init()        f_ab = mf_B.get_fock()        v_a = mf_B.get_veff(dm=dm_A)        hcore = f_ab - v_a                        # get electronic energy for MOs in active subsystem with bath method        self.energy_a, _ = mf_B.energy_elec(dm=dm_A, vhf=v_a, h1e=hcore)        # make embedding mean field object        mol.nelectron = int(2 * self.moC_occ_A.shape[1])        if xc_embed is None:            self.mf_A = scf.RHF(mol,**kwargs)                    else:            self.mf_A = dft.RKS(mol)            self.mf_A.xc = xc_embed                    if hasattr(mf_B, 'with_df'):            self.mf_A = df.density_fit(self.mf_A)            self.mf_A.with_df.auxbasis = mf_B.with_df.auxbasis                    mf_A = self.mf_A        mf_A.get_hcore = lambda *args: hcore                # get embedded MO energies and coefficients        moC_A = np.hstack([self.moC_occ_A,self.moC_vir_A])        fock = moC_A.T @ mf_A.get_fock(dm=dm_A) @ moC_A        e,u = np.linalg.eigh(fock)                mf_A.mo_energy = e        mf_A.mo_coeff = moC_A@u        mf_A.mo_occ = np.zeros(len(e),dtype=np.int64)        mf_A.mo_occ[0:self.moC_occ_A.shape[1]] = 2                        # get embedded electronic energy        v_a = mf_A.get_veff(dm=dm_A)        self.energy_embed, _ = mf_A.energy_elec(dm=dm_A, vhf=v_a, h1e=hcore)            # recombined energy with embedded part        self.e_tot = mf_B.e_tot - self.energy_a + self.energy_embed                return self.e_tot, mf_A.mo_energy, mf_A.mo_coeff, mf_A.mo_occ     #%%if __name__ == '__main__':    import matplotlib.pyplot as plt    import pyscf    from pyscf.tools import cubegen    from pyscf_embedding.local import regional as re    coords = \    """    O         -3.65830        0.00520       -0.94634    H         -4.10550        1.27483       -1.14033    C         -2.05632        0.04993       -0.35355    C         -1.42969        1.27592       -0.14855    C         -0.12337        1.31114        0.33487    C          0.54981        0.12269        0.61082    C         -0.08157       -1.10218        0.40403    C         -1.38785       -1.13991       -0.07931    H         -1.93037        2.15471       -0.35367    H          0.34566        2.21746        0.48856    H          1.51734        0.14971        0.96884    H          0.41837       -1.98145        0.60889    H         -1.85763       -2.04579       -0.23330    """    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RHF(max_cycles=100).run()    e_tot_hf = mf.e_tot.copy()        mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='pbe',max_cycles=100).run()    e_tot_pbe = mf.e_tot.copy()        mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='b3lyp',max_cycles=100).run()    e_tot_b3lyp = mf.e_tot.copy()    #%%    ##### Test DFT - in - DFT    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='pbe',max_cycles=100).run()    # mf = mol.RHF(max_cycles=100).run()    e_tot_arr1 = []    for i in range(1,9):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        vir_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'vir', basis='ccpvdz')        #         _,moC_occ,mask_occ_act = occ_calc.calc_mo()        _,moC_vir,mask_vir_act = vir_calc.calc_mo()        #        embed = rFixedDensity(mf, moC_occ, moC_vir, mask_occ_act, mask_vir_act)        e_tot,_,_,_ = embed.kernel(xc_embed='b3lyp',deltadm_corr=False)        print(embed.mf_A.mo_coeff.shape)        e_tot_arr1.append(e_tot)        plt.plot( (e_tot_arr1 - e_tot_hf)*27.2114, color="red")    plt.plot( [e_tot_b3lyp*27.2114 - e_tot_hf*27.2114]*len(e_tot_arr1), color="black")        #%%    ##### Test CCSD - in - DFT    mol = pyscf.M(atom=coords,basis='3-21g',verbose=4)    mf = mol.RHF(max_cycles=100).run()    mycc = pyscf.cc.CCSD(mf).run()    e_tot_ccsd = mycc.e_tot.copy()        mol = pyscf.M(atom=coords,basis='3-21g',verbose=4)    # mf = mol.RHF(max_cycles=100).run()    mf = mol.RKS(xc='b3lyp',max_cycles=100).run()    e_tot_dft = mf.e_tot.copy()    e_tot_arr1 = []    for i in range(1,13):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        vir_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'vir', basis='3-21g')        #         _,moC_occ,mask_occ_act = occ_calc.calc_mo()        _,moC_vir,mask_vir_act = vir_calc.calc_mo()        #        embed = rFixedDensity(mf, moC_occ, moC_vir, mask_occ_act, mask_vir_act)        e_tot,_,_,_ = embed.kernel(xc_embed=None)        mycc = pyscf.cc.CCSD(embed.mf_A,mo_coeff=embed.mf_A.mo_coeff)        mycc.kernel()                e_tot_arr1.append(e_tot + mycc.e_corr)        plt.plot( (e_tot_arr1 - e_tot_dft)*27.2114, color="red")    plt.plot( [e_tot_ccsd*27.2114 - e_tot_dft*27.2114]*len(e_tot_arr1), color="black")