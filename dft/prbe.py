#!/usr/bin/env python3# -*- coding: utf-8 -*-"""huzinaga.pyImplements Manby & Miller Projection Based Embedding using the Huzinaga Projection Operator. author: Ardavan Farahvash, github.com/afarahva"""import numpy as npfrom pyscf_embedding import libfrom pyscf import scf, dft, dffrom pyscf.scf import chkfilefrom pyscf.lib import logger, diisfrom functools import partialfrom pyscf import __config__TIGHT_GRAD_CONV_TOL = getattr(__config__, 'scf_hf_kernel_tight_grad_conv_tol', True)def huzinaga_kernel(mf, hcore, conv_tol=1e-10, conv_tol_grad=None,           dump_chk=True, dm0=None, callback=None, conv_check=True,            P_occ_B=None, P_vir_B=None, **kwargs):    cput0 = (logger.process_clock(), logger.perf_counter())    if conv_tol_grad is None:        conv_tol_grad = np.sqrt(conv_tol)        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)    mol = mf.mol    s1e = mf.get_ovlp(mol)    if dm0 is None:        dm = mf.get_init_guess(mol, mf.init_guess, s1e=s1e, **kwargs)    else:        dm = dm0    vhf = mf.get_veff(mol, dm)    """    ----- Set new core matrix -----    """    if hcore is not None:        h1e = hcore        if P_occ_B is not None:            m = (vhf + hcore) @ P_occ_B @ s1e            h1e = h1e - m - m.T                if P_vir_B is not None:            m = (vhf + hcore) @ P_vir_B @ s1e            h1e = h1e - m - m.T            # m = 2 * s1e @ P_vir_B  @ (vhf + hcore) @ P_vir_B @ s1e            h1e = h1e + m    else:        h1e = mf.get_hcore(mol)        mf.get_hcore = lambda *args: h1e    """    ----- Set new core matrix -----    """            e_tot = mf.energy_tot(dm, h1e, vhf)    logger.info(mf, 'init E= %.15g', e_tot)    scf_conv = False    mo_energy = mo_coeff = mo_occ = None    # Skip SCF iterations. Compute only the total energy of the initial density    if mf.max_cycle <= 0:        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS        mo_energy, mo_coeff = mf.eig(fock, s1e)        mo_occ = mf.get_occ(mo_energy, mo_coeff)        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ    if isinstance(mf.diis, diis.DIIS):        mf_diis = mf.diis    elif mf.diis:        assert issubclass(mf.DIIS, diis.DIIS)        mf_diis = mf.DIIS(mf, mf.diis_file)        mf_diis.space = mf.diis_space        mf_diis.rollback = mf.diis_space_rollback        mf_diis.damp = mf.diis_damp        # We get the used orthonormalized AO basis from any old eigendecomposition.        # Since the ingredients for the Fock matrix has already been built, we can        # just go ahead and use it to determine the orthonormal basis vectors.        fock = mf.get_fock(h1e, s1e, vhf, dm)        _, mf_diis.Corth = mf.eig(fock, s1e)    else:        mf_diis = None    if dump_chk and mf.chkfile:        # Explicit overwrite the mol object in chkfile        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"        chkfile.save_mol(mol, mf.chkfile)    # A preprocessing hook before the SCF iteration    mf.pre_kernel(locals())    fock_last = None    cput1 = logger.timer(mf, 'initialize scf', *cput0)    mf.cycles = 0    for cycle in range(mf.max_cycle):        dm_last = dm        last_hf_e = e_tot        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis, fock_last=fock_last)        mo_energy, mo_coeff = mf.eig(fock, s1e)        mo_occ = mf.get_occ(mo_energy, mo_coeff)        dm = mf.make_rdm1(mo_coeff, mo_occ)        vhf = mf.get_veff(mol, dm, dm_last, vhf)        e_tot = mf.energy_tot(dm, h1e, vhf)                """        ----- Huzinaga Projection Operator Applied Here -----        """        if hcore is not None:            h1e = hcore                        if P_occ_B is not None:                m = (vhf + hcore) @ P_occ_B @ s1e                h1e = h1e - m - m.T                        if P_vir_B is not None:                m = (vhf + hcore) @ P_vir_B @ s1e                h1e = h1e - m - m.T                m = 2 * s1e @ P_vir_B  @ (vhf + hcore) @ P_vir_B @ s1e                h1e = h1e + m                            mf.get_hcore = lambda *args: h1e        """        ----- Huzinaga Projection Operator Applied Here -----        """                # Here Fock matrix is h1e + vhf, without DIIS.  Calling get_fock        # instead of the statement "fock = h1e + vhf" because Fock matrix may        # be modified in some methods.        fock_last = fock        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))        if not TIGHT_GRAD_CONV_TOL:            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)        norm_ddm = np.linalg.norm(dm-dm_last)        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)        if callable(mf.check_convergence):            scf_conv = mf.check_convergence(locals())        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:            scf_conv = True        if dump_chk and mf.chkfile:            mf.dump_chk(locals())        if callable(callback):            callback(locals())        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)        if scf_conv:            break    mf.cycles = cycle + 1    if scf_conv and conv_check:        # An extra diagonalization, to remove level shift        #fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf        mo_energy, mo_coeff = mf.eig(fock, s1e)        mo_occ = mf.get_occ(mo_energy, mo_coeff)        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm        vhf = mf.get_veff(mol, dm, dm_last, vhf)        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot        fock = mf.get_fock(h1e, s1e, vhf, dm)        norm_gorb = np.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))        if not TIGHT_GRAD_CONV_TOL:            norm_gorb = norm_gorb / np.sqrt(norm_gorb.size)        norm_ddm = np.linalg.norm(dm-dm_last)        conv_tol = conv_tol * 10        conv_tol_grad = conv_tol_grad * 3        if callable(mf.check_convergence):            scf_conv = mf.check_convergence(locals())        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:            scf_conv = True        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)        if dump_chk and mf.chkfile:            mf.dump_chk(locals())    logger.timer(mf, 'scf_cycle', *cput0)    # A post-processing hook before return    mf.post_kernel(locals())    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occclass rPRBE:        def __init__(self, mf, moC_occ, moC_vir, mask_occ_act, mask_vir_act):                # fragment mf object (to be set by kernel)        self.mf_A = None                # bath mf object        self.mf_B = mf                # partition the MOs        if moC_occ is None:            moC_occ = mf.mo_coeff[:,mf.mo_occ >= 1]                        if moC_vir is None:            moC_vir = mf.mo_coeff[:,mf.mo_occ < 1]                 if mask_occ_act is None:            self.moC_occ_A = moC_occ            self.moC_occ_B = \            np.array([], dtype=np.float64).reshape(moC_occ.shape[0],0)        else:            self.moC_occ_A = moC_occ[:,mask_occ_act]            self.moC_occ_B = moC_occ[:,~mask_occ_act]                    if mask_vir_act is None:            self.moC_vir_A = moC_vir            self.moC_vir_B = \            np.array([], dtype=np.float64).reshape(moC_vir.shape[0],0)        else:            self.moC_vir_A = moC_vir[:,mask_vir_act]            self.moC_vir_B = moC_vir[:,~mask_vir_act]            def make_rdmA_init(self):        dm_A = 2 * self.moC_occ_A @ self.moC_occ_A.T        return dm_A                def make_rdmA_embed(self):        if self.mf_A is None:            return         else:            return self.mf_A.make_rdm1()                def get_vembed(self, dm_A=None):        if dm_A is None:            dm_A = self.make_rdmA_init()                v_ab = self.mf_B.get_veff()        v_a = self.mf_B.get_veff(dm=dm_A)        v_embed = v_ab - v_a        return v_embed        def get_hcore_embed(self, v_embed=None, dm_A=None):        if v_embed is None:            v_embed = self.get_vembed(dm_A=dm_A)        hcore = v_embed + self.mf_B.get_core()        return hcore        def get_huzinaga(self, fock, s):                P_occ_B = self.moC_occ_B @ self.moC_occ_B.T        P_vir_B = self.moC_vir_B @ self.moC_vir_B.T        nao = self.mf_B.mol.nao        projector = np.zeros((nao,nao),dtype=np.float64)                if P_occ_B is not None:            M = fock @ P_occ_B @ s            projector = projector - M - M.T                if P_vir_B is not None:            M = fock @ P_vir_B @ s            projector = projector - M - M.T            M = 2 * s @ P_vir_B @ fock @ P_vir_B @ s            projector = projector + M                return projector        def energy_tot(self, energy_A=None, dm_A=None):                if self.mf_A is None:            return                 if energy_A is None:            if dm_A is None:                dm_A = self.make_rdmA_init()                            v_a = self.mf_B.get_veff(dm=dm_A)            hcore = self.get_hcore_embed(dm_A=dm_A)            energy_A, _ = self.mf_B.energy_elec(dm=dm_A, vhf=v_a, h1e=hcore)                    energy_AB = self.mf_B.energy_tot()        energy_embed = self.mf_A.energy_tot() - self.mf_A.energy_nuc()                return energy_AB + energy_embed - energy_A            def energy_deltadm(self, dm_A_embed=None, dm_A=None, v_embed=None):        if dm_A_embed is None:            dm_A_embed = self.make_rdmA_embed()                    if dm_A is None:            dm_A = self.make_rdmA_init()                    if v_embed is None:            v_embed = self.get_vembed(dm_A=dm_A)                    deltaE = np.trace( (dm_A_embed - dm_A)@ (self.mf_A.get_hcore()-self.mf_B.get_hcore()) )        return deltaE        def kernel(self, xc_embed=None, ecp_embed=None, pseudo_embed=None, deltadm_corr=False, filtermo=True, **kwargs):                mf_B = self.mf_B                # copy input mf        ovlp = mf_B.get_ovlp()        mol = mf_B.mol.copy()        mol.nelectron = int(2 * self.moC_occ_A.shape[1])                # build embedding potential and effective core potential        dm_A0 = self.make_rdmA_init()        f_ab = mf_B.get_fock()        v_a = mf_B.get_veff(dm=dm_A0)        hcore = f_ab - v_a                # construct huzinaga projector        projector = self.get_huzinaga(f_ab, ovlp)        self.projector = projector                # get electronic energy for MOs in active subsystem        self.energy_a, _ = mf_B.energy_elec(dm=dm_A0, vhf=v_a, h1e=hcore+projector)        # make embedding mean field object                if xc_embed is None:            self.mf_A = scf.RHF(mol,**kwargs)                    else:            self.mf_A = dft.RKS(mol)            self.mf_A.xc = xc_embed                    if hasattr(mf_B, 'with_df'):            self.mf_A = df.density_fit(self.mf_A)            self.mf_A.with_df.auxbasis = mf_B.with_df.auxbasis                    mf_A = self.mf_A        mf_A.diis_space = mf_B.diis_space        mf_A.max_cycle = mf_B.max_cycle                # set special embedding methods        mf_A.get_hcore = lambda *args: hcore        new_kernel = partial(huzinaga_kernel, mf=mf_A, hcore=hcore,                              P_occ_B = self.moC_occ_B @ self.moC_occ_B.T,                             P_vir_B = self.moC_vir_B @ self.moC_vir_B.T)                # run embedded SCF        mf_A.converged, mf_A.e_tot, mf_A.mo_energy, \            mf_A.mo_coeff, mf_A.mo_occ = new_kernel(dm0=dm_A0)                    self.energy_embed = mf_A.e_tot        # find indices of bath/frozen MOs        epsilon = 1e-5        mask_act = np.linalg.norm( \          mf_A.mo_coeff.T @ ovlp @ np.hstack([self.moC_occ_B,self.moC_vir_B])\                    ,axis=1) <= epsilon                    mf_A.mo_energy = mf_A.mo_energy[mask_act]        mf_A.mo_coeff = mf_A.mo_coeff[:,mask_act]        mf_A.mo_occ = mf_A.mo_occ[mask_act]                # calculate total energy        energy_a_in_b = self.energy_embed - mf_A.energy_nuc()                        # recombined energy with embedded part        self.e_tot = mf_B.e_tot - self.energy_a + energy_a_in_b                if deltadm_corr:            self.deltaE_dm = self.energy_deltadm()            self.e_tot = self.e_tot + self.deltaE_dm                return self.e_tot, mf_A.mo_energy, mf_A.mo_coeff, mf_A.mo_occ     #%%if __name__ == '__main__':    import matplotlib.pyplot as plt    import pyscf    from pyscf.tools import cubegen    from pyscf_embedding.local import regional as re    coords = \    """O -2.353712 -1.844251 4.337036H -2.817118 -1.606664 5.158222C -1.505782 -0.753062 4.006481C -0.757774 -1.082554 2.722439C 0.176016 0.052119 2.306948C 0.923642 -0.286621 1.016326C 1.858203 0.849191 0.600650C 2.603371 0.516299 -0.682091H -2.123330 0.141895 3.880182H -0.808204 -0.591001 4.834362H -0.189417 -2.010764 2.861341H -1.481117 -1.290922 1.924157H -0.404332 0.971881 2.164720H 0.897927 0.246154 3.109563H 1.503945 -1.206490 1.158392H 0.201800 -0.480825 0.213630H 2.584623 1.044614 1.398039H 1.282425 1.770307 0.453238H 3.215076 -0.383056 -0.558342H 1.905658 0.346660 -1.508381H 3.265681 1.341868 -0.960827    """    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RHF(max_cycles=100).run()    e_tot_hf = mf.e_tot.copy()        mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='LDA',max_cycles=100).run()    e_tot_pbe = mf.e_tot.copy()        mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mf = mol.RKS(xc='b3lyp',max_cycles=100).run()    e_tot_b3lyp = mf.e_tot.copy()        #%%    ##### Test DFT - in - DFT    mol = pyscf.M(atom=coords,basis='ccpvdz',verbose=4)    mol.RKS(xc='LDA',max_cycles=100).run()    mf = mol.RHF(max_cycles=100).run()    e_tot_arr1 = []    e_tot_arr2 = []    for i in range(1,9):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        vir_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'vir', basis='ccpvdz')                #         _,moC_occ,mask_occ_act = occ_calc.calc_mo()        # _,moC_vir,mask_vir_act = vir_calc.calc_mo()        #                embed = rPRBE(mf, moC_occ, None, mask_occ_act, None)        e_tot,mo_energy,mo_coeff,mo_occ = embed.kernel(xc_embed='b3lyp',deltadm_corr=False)        print(e_tot)        deltaE_dm = embed.energy_deltadm()                e_tot_arr1.append(e_tot)        e_tot_arr2.append(e_tot+deltaE_dm)        plt.figure()    plt.plot( (e_tot_arr1 - e_tot_pbe)*27.2114, color="red")    plt.plot( (e_tot_arr2 - e_tot_pbe)*27.2114, color="blue")    plt.plot( [e_tot_b3lyp*27.2114 - e_tot_pbe*27.2114]*len(e_tot_arr1), color="black")        #%%    ##### Test CCSD - in - DFT    mol = pyscf.M(atom=coords,basis='3-21g',verbose=4)    mf = mol.RHF(max_cycles=100).run()    mycc = pyscf.cc.CCSD(mf).run()    e_tot_ccsd = mycc.e_tot.copy()        mol = pyscf.M(atom=coords,basis='3-21g',verbose=4)    # mf = mol.RHF(max_cycles=100).run()    mf = mol.RKS(xc='b3lyp',max_cycles=100).run()    e_tot_dft = mf.e_tot.copy()    e_tot_arr1 = []    e_tot_arr2 = []    for i in range(1,5):        occ_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'occ', basis='minao')        vir_calc = re.rRegionalActiveSpace(mf, np.arange(0,i+1), 'vir', basis='3-21g')        #         _,moC_occ,mask_occ_act = occ_calc.calc_mo()        _,moC_vir,mask_vir_act = vir_calc.calc_mo()        #                embed = rPRBE(mf, moC_occ, moC_vir, mask_occ_act, mask_vir_act)        e_tot,_,_,_ = embed.kernel(xc_embed=None)        deltaE_dm = np.trace( (embed.mf_A.make_rdm1() - embed.make_rdmA_init())@ (embed.mf_A.get_hcore()-embed.mf_B.get_hcore()) )                mycc = pyscf.cc.CCSD(embed.mf_A)        mycc.kernel()                e_tot_arr1.append(e_tot + mycc.e_corr)        e_tot_arr2.append(e_tot + mycc.e_corr + deltaE_dm)        plt.figure()    plt.plot( (e_tot_arr1 - e_tot_dft)*27.2114, color="red")    plt.plot( (e_tot_arr2 - e_tot_dft)*27.2114, color="blue")    plt.plot( [e_tot_ccsd*27.2114 - e_tot_dft*27.2114]*len(e_tot_arr1), color="black")